## Install
Run the script `install.sh`, or you can do it manually as follows:

Build and install the C++ library `myrender` first:
```bash
mkdir build
cd build
cmake ..
make -j
sudo make install
```
The built library `libmyrender.so` will be put in `/usr/local/lib`. If you don't want to install the library, you need to specify `LD_LIBRARY_PATH` before you import the `simplerender` module, since the `simplerender` module needs to load the library when imported.

Build and install the `simplerender` module:
```bash
python setup.py install --user
```

Basically, the core rendering function is implemented in C++ with OpenGL support. We use swig to automatically generate python interfaces for C++ functions.

## Usage
To import the edge/depth rendering functions:
```python
from feh_render.simplerender import render_edge, render_depth
```

Run the following to get depth/edge map of a chair.
```bash
python test_render_basic.py
```

In `test_render_basic.py`, the raw python wrappers generated by swig are used, which are not quite nice. Thus on top of the raw python wrappers, we implemented a Camera class, which exposes much nicer interfaces. Run `test_camera.py` to see how it works. `from feh_render.camera import Camera` to use this camera class in your projects.


See the demo code for detailed usages.

Note, type of input arguments should match the required one exactly, i.e., vertices should be float32, faces should be uint32, intrinsics should be float32, imgsize should be int32, depth should be uint8 and edge should be uint8.

Essentially, depth map should have floating-point values, however we convert the actual depth via
$$
\tilde{z}=\frac{z_{near} z_{far}}{(z_{far}-z_{near}) - z\cdot(z_{far}-z_{near})}
$$
and normalize them to $[0, 1]$ and convert them to unsigned char.

## Work with GLSL

GLSL stands for *OpenGL Shading Language*, which is a programming language similar to C. Not sure how the professionals work with the shading language, but to work with GLSL in a C/C++ framework, I found the following workflow quite nice:

- Write vertex/fragment/geometry shader as usual, name them as `XXX.vert/XXX.frag/XXX.geom` and put them in `include` folder.
- Use the python script `generate_shader_strings.py` to generate `const std::string`s and include them in `GLRender.cpp`.
- Need to add corresponding entries in the python script to generate such strings.
- Also, once you modified the python script, you can rely on the cmake build system to automatically trigger the script to generate `XXX.i` files.
- Of course you need to manually include and assign the desired shader strings to shaders -- this is part of development.

## OpenGL-CUDA Interoperability
OpenGL has all the power to render depth map without any difficulty and CNN also runs on the graphics card. In addition, we can do edge extraction on the rendered depth image via either an OpenGL shader or CUDA. To compare the edge maps from a render engine and CNN, it seems natural to hand all the computation to GPU and never leave the graphics card.

To do this, we can leverage the **OpenGL-CUDA interoperability**, which provides a mechanism for CUDA code to access texture buffers inside OpenGL code.

For more details, see my notes (`interop.md`) on this topic and also [this](https://www.3dgep.com/opengl-interoperability-with-cuda/) online tutorial.

## OpenGL Compute Shader
We ended up using OpenGL Compute Shader to carry the likelihood evaluation to save the context switch between OpenGL and CUDA, which is not negligible.


## Debug

Run `test_render` in bin directoryto debug. To get detailed debug info, use glog's verbose logging flag:

```bash
GLOG_v=YOUR_VERBOSE_LEVEL ./test_render
```

## Loader Generator
Instead of GLEW which contains every possible version of OpenGL function pointers, we use a loader generator [*glad*](https://github.com/Dav1dde/glad) to load a minimal set of OpenGL functions. Also, the functions are built together with the renderer library, thus we do not need to rely on thirdparty libraries, such as GLEW.





## TODO
~~- Efficient edge rendering with shader ...~~

- Differentiable rendering?

~~- Make the model-view-projection work.~~

- More efficient reduction with compute shader.
  - Current implementation of reduction in compute shader is simple and slow, may speed it further by using shared memory inside a workgroup (Memory shared by all invocations inside the same workgroup).
